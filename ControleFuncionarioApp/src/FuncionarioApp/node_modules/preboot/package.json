{
  "_args": [
    [
      "preboot@https://registry.npmjs.org/preboot/-/preboot-4.5.2.tgz",
      "C:\\Users\\Glaucia\\Downloads\\Labs\\simple-crud-core-angular\\ControleFuncionarioApp\\src\\FuncionarioApp"
    ]
  ],
  "_from": "preboot@4.5.2",
  "_id": "preboot@4.5.2",
  "_inCache": true,
  "_location": "/preboot",
  "_phantomChildren": {},
  "_requested": {
    "name": "preboot",
    "raw": "preboot@https://registry.npmjs.org/preboot/-/preboot-4.5.2.tgz",
    "rawSpec": "https://registry.npmjs.org/preboot/-/preboot-4.5.2.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/preboot/-/preboot-4.5.2.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "#DEV:/"
  ],
  "_resolved": "https://registry.npmjs.org/preboot/-/preboot-4.5.2.tgz",
  "_shasum": "cb349209958c2b48d7f74137b3499bbbe5472a5e",
  "_shrinkwrap": null,
  "_spec": "preboot@https://registry.npmjs.org/preboot/-/preboot-4.5.2.tgz",
  "_where": "C:\\Users\\Glaucia\\Downloads\\Labs\\simple-crud-core-angular\\ControleFuncionarioApp\\src\\FuncionarioApp",
  "author": {
    "name": "Jeff Whelpley"
  },
  "browser": "__dist/preboot_browser.js",
  "bugs": {
    "url": "https://github.com/angular/preboot/issues"
  },
  "contributors": [
    {
      "name": "Tobias Bosch",
      "email": "tbosch@google.com"
    },
    {
      "name": "PatrickJS",
      "email": "github@gdi2290.com"
    },
    {
      "name": "Jeff Whelpley",
      "email": "jeff@gethuman.com"
    }
  ],
  "dependencies": {},
  "description": "Record and play back browser events",
  "devDependencies": {
    "@types/es6-promise": "0.0.29",
    "@types/jasmine": "^2.2.31",
    "@types/node": "^6.0.33",
    "connect-livereload": "^0.5.4",
    "del": "^2.2.1",
    "express": "^4.14.0",
    "gulp": "^3.9.1",
    "gulp-jasmine": "^2.4.0",
    "gulp-livereload": "^3.8.1",
    "gulp-rename": "^1.2.2",
    "gulp-replace": "^0.5.4",
    "gulp-size": "^2.1.0",
    "gulp-tslint": "^6.0.2",
    "gulp-typedoc": "^2.0.0",
    "gulp-typescript": "^2.13.6",
    "gulp-uglify": "^2.0.0",
    "open": "0.0.5",
    "serve-static": "^1.11.1",
    "tslint": "^3.14.0",
    "typedoc": "^0.4.4",
    "typescript": "2.1.0-dev.20160801"
  },
  "homepage": "https://github.com/angular/preboot",
  "license": "MIT",
  "main": "__build/src/node/preboot_node.js",
  "name": "preboot",
  "optionalDependencies": {},
  "readme": "# preboot\n\nThe purpose of this library to to help manage the transition of state (i.e. events, focus, data) from\na server-generated web view to a client-generated web view. The most common use cases include:\n\n* Universal apps that re-render (ex. Angular 2) - The client app generates a brand new view that replaces the server view\n* Universal apps that hydrate (ex. React) - The client app attaches to the existing server view\n* Static server-side \"shells\" (ex. Server Worker Application Shell) - A static, sparse template is used for the initial page load \n\n## Key Features\n\n1. Record and play back events\n1. Respond immediately to certain events\n1. Maintain focus even page is re-rendered\n1. Buffer client-side re-rendering for smoother transition\n1. Freeze page until bootstrap complete for certain events\n\n## Preboot Modules\n\nIt is important to note that there are 3 differet parts of preboot:\n\n1. **Inline** - This is the code that is injected into the HEAD of your server view and \nis in charge of recording all server view events.\n2. **Node** - The node.js library for preboot really just exists to generate the inline code.\n3. **Browser** - This client side library should not be inlined, but it should be loaded as a \nfile BEFORE your client side application code. This library is in charge of replaying all the\nevents on the client view and then switching from server view to client view.\n\nNOTE: The inline code will add an object `prebootData` onto the global window scope that contains\nall the recorded events and other application details. The browser code will pick up this global\nobject and replay the events from this object onto the client view.\n\n## Installation\n\nThis is a server-side library that generates client-side code.\nTo use this library, you would first install it through npm:\n\n```sh\nnpm install preboot\n```\n\nThen in your server-side code you would do something like this:\n\n```es6\nvar preboot = require('preboot');\nvar prebootOptions = {};  // see options section below\nvar inlinePrebootCode = preboot.getInlineCode(opts);\n```\n\nYou then inject `inlinePrebootCode` into the HEAD section of your server-side template.\nThen, at the very bottom of your `body` tag in your server-side template, add a reference\nto the preboot client and have some way of calling `preboot.complete()`:\n\n```html\n<body>\n\n\n  <script src=\"preboot_client.min.js\"></script>\n  <script>\n  \n    // have some way to call this once the client is done loading\n    function callPrebootComplete() {\n    \n      // preboot is global object added by the preboot_client\n      preboot.complete();\n    }\n  \n  </script>\n</body>\n```\n\nAt a high level, you want to call `preboot.complete()` once the client is done bootstrapping/loading.\nThe exact way in which this is done will be different for each type of client side app. For Angular 2\nfor example, you can call it like this:\n\n```es6\nbootstrap(MyRootComponent, [PROVIDERS])\n  .then(function () {\n    preboot.complete();\n  });\n```\n\nOne thing to watch out for, though, is that if you are not caching data between your client and server,\nthen you should probably set up way of calling `preboot.complete()` after the initial client side async\ncalls are all done. Otherwise, the async calls may not complete until AFTER preboot is complete which \nlikely will result in jank. HOWEVER, our recommendation for this is to focus on data caching rather\nthan trying to delay `preboot.complete()` until after async calls are done.\n\n## Options\n\nHere is a detailed explanation of each option you can pass into `getInlineCode(opts)` for the\nnode version of preboot.\n\n* `eventSelectors` - This is an array of objects which specify what events preboot should be listening for \non the server view and how preboot should replay those events to the client view. \nSee Event Selector section below for more details but note that in most cases, you can just rely on the defaults\nand you don't need to explicitly set anything here.\n* `appRoot` - This is one or more selectors for apps in the page (i.e. so one string or an array of strings).\n* `serverClientRoot` - This is an alternative to appRoot which can be used when you are doing manual buffering. \nThe value here is an array of objects which contain `serverSelector` and `clientSelector`. \nSee more in buffering section below. \n* `buffer` - If true, preboot will attempt to buffer client rendering to an extra hidden div. \nSee more in buffering section below.\n* `uglify` - If true, the code returned from `getInlineCode(opts)` will be uglified. \n* `noInlineCache` - By default the results of `getInlineCode(opts)` are cached internally for each different type\nof `opts` object passed in. This is done for perf reasons in case it is being called at \nruntime for every server request.\n* `window` - This will override the actual window object and is only used for testing purposes.\n\n## Event Selectors\n\nThis part of the options drives a lot of the core behavior of preboot. \nEach event selector has the following properties:\n\n* `selector` - The selector to find nodes under the server root (ex. `input,.blah,#foo`)\n* `events` - An array of event names to listen for (ex. `['focusin', 'keyup', 'click']`)\n* `keyCodes` - Only do something IF event includes a key pressed that matches the given key codes.\nUseful for doing something when user hits return in a input box or something similar.\n* `preventDefault` - If true, `event.preventDefault()` will be called to prevent any further event propagation.\n* `freeze` - If true, the UI will freeze which means displaying a translucent overlay which prevents\nany further user action until preboot is complete.\n* `action` - This is a function callback for any custom code you want to run when this event occurs \nin the server view.\n* `noReplay` - If true, the event won't be recorded or replayed. Useful when you utilize one of the other options above.\n\nHere are some examples of event selectors from the defaults:\n\n```es6\nvar eventSelectors = [\n\n  // for recording changes in form elements\n  { selector: 'input,textarea', events: ['keypress', 'keyup', 'keydown', 'input', 'change'] },\n  { selector: 'select,option', events: ['change'] },\n\n  // when user hits return button in an input box\n  { selector: 'input', events: ['keyup'], preventDefault: true, keyCodes: [13], freeze: true },\n\n  // for tracking focus (no need to replay)\n  { selector: 'input,textarea', events: ['focusin', 'focusout', 'mousedown', 'mouseup'], noReplay: true },\n\n  // user clicks on a button\n  { selector: 'input[type=\"submit\"],button', events: ['click'], preventDefault: true, freeze: true }\n];\n```\n\n## Buffering\n\nBuffering is when the client application initially renders to a hidden div and once the client is ready,\npreboot will switch the server and client view in one shot. This is probably NOT needed for client-side \nframeworks that do a good job at hydration (i.e. re-using the server view) like React. For everyone\nelse, though, buffering is extremely useful (especially as your page becomes bigger and more complex)\n \nThere are two basic ways to do buffering with preboot:\n\n1. **Automatic buffering** - This is where you let preboot generate an extra hidden div where your client \napp will write to. To do this, simply set `buffer: true` in your preboot options.\n2. **Manual buffering** - This is where you manually create your own hidden div for your client view. To do\nthis, make sure you set `buffer: false` and then use `serverClientRoot` instead of `appRoot` in your \npreboot options so you can specify both `serverSelector` and `clientSelector`.\n\nWhy would you want manually handle buffering? This can be extremely useful for situations where you are \nNOT working with a truly isomorphic framework. So, for example, with Angular 1 or App Shell (from Progressive Web Apps).\n\n## Contributor Notes\n\nSome misc important things to keep in mind for contributors (in no particular order):\n\n* There are no downstream dependencies for preboot. This is done on purpose to keep preboot as light as possible.\n* There are only 3 main code files for preboot. One for each of the different parts (i.e. inline, browser, node). Don't\nbreak from this paradigm for now.\n* The transpiled `prebootstrap()` function is inlined in the server view, so it should be as small as possible \n(goal is to keep the uglified version under 3k).\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/angular/preboot.git"
  },
  "scripts": {
    "prepublish": "gulp dist"
  },
  "typings": "preboot.d.ts",
  "version": "4.5.2"
}
